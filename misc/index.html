<!doctype html>
<html>
<script>
    const parseQuadcode = (string) => {
        let accum = [];

        for (let i = 0; i < string.length; i++) {
            let ch = string.at(i);
            if (ch >= '0' && ch <= '9')
                accum.push(ch);
        }

        return accum.join('');
    }

    const parseInFrustumEventBodyFromPtr = (Module, ptr) => {
        const tilecode = [
            Module.getValue(ptr, 'i32'),
            Module.getValue(ptr + 4, 'i32'),
            Module.getValue(ptr + 8, 'i32'),
        ];

        ptr += 12;

        const center = [
            Module.getValue(ptr, 'float'),
            Module.getValue(ptr + 4, 'float'),
        ];

        ptr += 8;

        const sideLength = Module.getValue(ptr, 'float');

        return {
            tileCode: tilecode,
            center: center,
            sideLength: sideLength
        };
    }

    const parseBaseMeshFromPtr = (Module, ptr) => {
        let lengthPtr = Module._malloc(4);
        Module.setValue(lengthPtr, 0, 'i32');

        let length;

        // parse vertices
        const verticesPtr = Module.getMeshVertices(ptr, lengthPtr);

        length = Module.getValue(lengthPtr, 'i32');
        const verticesBuffer = new Float32Array(length);
        verticesBuffer.set(HEAPF32.subarray(verticesPtr / 4, verticesPtr / 4 + length));


        // parse normals
        const normalsPtr = Module.getMeshNormals(ptr, lengthPtr);

        length = Module.getValue(lengthPtr, 'i32');
        const normalBuffer = new Float32Array(length);
        normalBuffer.set(HEAPF32.subarray(normalsPtr / 4, normalsPtr / 4 + length));


        // parse uvs
        const uvsPtr = Module.getMeshUVs(ptr, lengthPtr);

        length = Module.getValue(lengthPtr, 'i32');
        const uvsBuffer = new Float32Array(length);
        normalBuffer.set(HEAPF32.subarray(uvsPtr / 4, uvsPtr / 4 + length));

        // parse indices
        const indicesPtr = Module.getMeshIndices(ptr, lengthPtr);

        length = Module.getValue(lengthPtr, 'i32');
        const indicesBuffer = new Uint32Array(length);
        indicesBuffer.set(HEAPU32.subarray(indicesPtr / 4, indicesPtr / 4 + length));

        return {
            vertices: verticesBuffer,
            normals: normalBuffer,
            uvs: uvsBuffer,
            indices: indicesBuffer
        };
    }

    const parseTerrainEventBodyFromPtr = (Module, ptr) => {
        return parseBaseMeshFromPtr(Module, ptr);
    }

    const parseJSONEventTransmissionObjectFromPtr = (Module, payloadPtr) => {
        const meshPtr = Module.getPointerToMeshFromTransObject(payloadPtr);
        const mesh = parseBaseMeshFromPtr(Module, meshPtr);

        const type = Module.getValue(payloadPtr, 'i32');
        payloadPtr += 4;

        const mainShapeCoordsCount = Module.getValue(payloadPtr, 'i32');
        payloadPtr += 4;

        const holeShapeCoordsCount = Module.getValue(payloadPtr, 'i32');
        payloadPtr += 4;

        const mainShapePositionsPtr = Module.getValue(payloadPtr, 'i32');
        payloadPtr += 4;

        const holeShapePositionsPtr = Module.getValue(payloadPtr, 'i32');
        payloadPtr += 8;

        const height = Module.getValue(payloadPtr, 'float');

        return {
            type: type,
            mainShapeCoordsCount: mainShapeCoordsCount,
            holeShapeCoordsCount: holeShapeCoordsCount,
            mainShapePositionsPtr: mainShapePositionsPtr,
            holeShapePositionsPtr: holeShapePositionsPtr,
            mesh: mesh,
            height: height
        };
    }

    const parseJSONEventBodyFromPtr = (Module, payloadPtr) => {
        // get length
        let lengthPtr = Module._malloc(4);
        Module.setValue(lengthPtr, 0, 'i32');

        let transObjPtr = Module.getJSONTransObjects(payloadPtr, lengthPtr);
        let length = Module.getValue(lengthPtr, 'i32');

        let transObjects = [];
        for (let i = 0; i < length; i++) {
            transObjects.push(parseJSONEventTransmissionObjectFromPtr(Module, transObjPtr));
            transObjPtr += 28;
        }

        return transObjects;
    }

    const parseEventBodyFromPtr = (Module, ptr) => {
        let type = Module.getValue(ptr, 'i32');

        ptr += 4;

        const decoder = new TextDecoder();
        const strCopy = new Uint8Array(32);
        strCopy.set(HEAPU8.subarray(ptr, ptr + 31));
        const str = decoder.decode(strCopy);

        ptr += 32;

        let payloadPtr = Module.getValue(ptr, 'i32');

        switch (type) {
            case 0:
                return {
                    type: type,
                    quadcode: parseQuadcode(str),
                    payload: parseInFrustumEventBodyFromPtr(Module, payloadPtr)
                };
            case 1:
                return {
                    type: type,
                    quadcode: parseQuadcode(str),
                };
            case 4:
                return {
                    type: type,
                    quadcode: parseQuadcode(str),
                    payload: parseTerrainEventBodyFromPtr(Module, payloadPtr)
                }
            case 5:
                return {
                    type: type,
                    quadcode: parseQuadcode(str),
                    payload: parseJSONEventBodyFromPtr(Module, payloadPtr)
                }
            default:
                return {
                    type: type,
                    quadcode: parseQuadcode(str),
                    payloadPtr: payloadPtr
                };
        }
    }

    const parseEventsArrayFromPtr = (Module, functor) => {
        let eventObjects = [];

        // get length
        let lengthPtr = Module._malloc(4);
        Module.setValue(lengthPtr, 0, 'i32');

        let eventsPtr = functor(lengthPtr);
        let length = Module.getValue(lengthPtr, 'i32');

        Module._free(lengthPtr);

        for (let i = 0; i < length; i++) {
            eventObjects.push(parseEventBodyFromPtr(Module, eventsPtr));
            eventsPtr += 32 + 4 + 4;
        }

        return eventObjects;
    }

    const parseAsyncEventsArrayFromPtr = (Module) => {
        return parseEventsArrayFromPtr(Module, Module.getAsyncEvents);
    }

    const parseSyncEventsArrayFromPtr = (Module) => {
        return parseEventsArrayFromPtr(Module, Module.getSyncEvents);
    }

    var Module = {
        onRuntimeInitialized: () => {
            Module.start(46.7197, 142.5233);
            Module.update(
                1000.0, 10000.0, 10000.0,
                0.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                1920, 1080
            );

            setTimeout(() => {
                let syncEventsObjects = parseSyncEventsArrayFromPtr(Module);
                console.log(syncEventsObjects);
            }, 0);

            setTimeout(() => {
                let asyncEventsObjects = parseAsyncEventsArrayFromPtr(Module);
                console.log(asyncEventsObjects);
            }, 5000);
        }
    };
</script>
<script src="karafuto_core.js"></script>
</html>